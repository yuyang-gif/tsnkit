"""
Author: YuYangyang (yuyangyang2023110770@gmail.com)
e_tsn.py (c) 2024
Desc: description
Created:  2024-08-05
"""

from typing import Dict
from typing import Set

from tsnkit.utils._constants import T_SLOT
from .. import utils
import z3  # type: ignore
import traceback

VarDict = Dict[utils.Stream, Dict[utils.Link, Dict[str, z3.ArithRef]]]
# VarDict = Dict[String, Dict[utils.Link, Dict[str, z3.ArithRef]]]

def benchmark(
    name, task_path, net_path, output_path="./", workers=1
) -> utils.Statistics:
    stat = utils.Statistics(name)  ## Init empty stat
    try:
        ## Change _Method to your method class
        test = e_tsn(workers)  # type: ignore
        test.init(task_path, net_path)
        test.prepare()
        stat = test.solve()  ## Update stat
        if stat.result == utils.Result.schedulable:
            test.output().to_csv(name, output_path)
        stat.content(name=name)
        return stat
    except KeyboardInterrupt:
        stat.content(name=name)
        return stat
    except Exception as e:
        print("[!]", e, flush=True)
        # 打印异常信息和异常发生的位置
        traceback.print_exc()
        print("[!]", e, flush=True)

    # 设置错误状态
    stat.result = utils.Result.error
    stat.content(name=name)

    return stat


class e_tsn:
    def __init__(self, workers=1) -> None:
        self.workers = workers

    def init(self, task_path, net_path) -> None:
        self.task = utils.load_stream(task_path)
        self.net = utils.load_network(net_path)
        self.task.set_routings(
            {s: self.net.get_shortest_path(s.src, s.dst) for s in self.task.streams}
        )

        z3.set_param("parallel.enable", True)
        z3.set_param("parallel.threads.max", self.workers)
        self.solver = z3.Solver()
        self.task_vars = self.create_task_vars(self.task) 

    def prepare(self) -> None:
        self.add_frame_const(self.solver, self.task_vars)
        self.add_flow_trans_const(self.solver, self.task_vars)
        self.add_delay_const(self.solver, self.task_vars)
        self.add_link_const(self.solver, self.task_vars, self.net, self.task)
        self.add_queue_range_const(self.solver, self.task_vars)
        self.add_frame_isolation_const(self.solver, self.task_vars, self.task)

    @utils.check_time_limit
    def solve(self) -> utils.Statistics:
        self.solver.set("timeout", int(utils.T_LIMIT - utils.time_log()) * 1000)
        result = self.solver.check()  ## Z3 solving

        info = self.solver.statistics()
        algo_time = info.time
        algo_mem = info.max_memory
        algo_result = (
            utils.Result.schedulable if result == z3.sat else utils.Result.unschedulable
        )

        self.model_output = self.solver.model()
        return utils.Statistics("-", algo_result, algo_time, algo_mem)

    def output(self) -> utils.Config:
        config = utils.Config()
        config.gcl = self.get_gcl_list(self.model_output, self.task_vars, self.task.lcm)
        config.release = self.get_release_time(self.model_output, self.task_vars)
        config.queue = self.get_queue_assignment(self.model_output, self.task_vars)
        config.route = self.get_route(self.task_vars)
        config._delay = self.get_delay(self.model_output, self.task_vars)
        return config

    @staticmethod
    def create_task_vars(tasks: utils.StreamSet) -> VarDict:
        task_var: VarDict = {}
        for s in tasks:
            task_var.setdefault(s, {})
            for l in s.routing_path.links:
                task_var[s].setdefault(l, {})
                task_var[s][l]["phi"] = z3.Int("phi_" + str(s) + "_" + str(l))
                task_var[s][l]["p"] = z3.Int("p_" + str(s) + "_" + str(l))
                task_var[s][l]["trans"] = s.t_trans # 增加链路传输时隙属性
        
        # 谨慎时隙预留
        et_processed : Dict[int, Set[int]] = {}
        for s1, s2 in tasks.get_pairs(): #返回一个二元组，0，1  0，2 1，2
            if s1.s_type == "Prob" and s2.s_type == "Det" and int(s1.shareOrET) not in et_processed.setdefault(int(s2._id),set()):
                for l in tasks.get_shared_links(s1,s2):  
                    task_var[s2][l]["trans"] += task_var[s1][l]["trans"]
                    et_processed[int(s2._id)].add(int(s1.shareOrET))
            elif s2.s_type == "Prob" and s1.s_type == "Det" and int(s2.shareOrET) not in et_processed.setdefault(int(s1._id),set()):
                for l in tasks.get_shared_links(s1,s2):  
                    task_var[s1][l]["trans"] += task_var[s2][l]["trans"]
                    et_processed[int(s1._id)].add(int(s2.shareOrET))
                     
        return task_var


    @staticmethod
    #帧偏移约束
    def add_frame_const(solver: z3.Solver, var: VarDict) -> None:
        for s in var.keys():
            for l in var[s].keys():
                solver.add(
                    var[s][l]["phi"] >= 0, var[s][l]["phi"] <= s.period - var[s][l]["trans"]
                )
                #概率流的调度时间大于其发生时间
                if s.s_type == "Prob":
                    solver.add(var[s][l]["phi"] >= s.ot)

    # 相邻链路约束
    @staticmethod
    def add_flow_trans_const(solver: z3.Solver, var: VarDict) -> None:
        for s in var.keys():
            for l in var[s].keys():
                next_hop = s.routing_path.get_next_link(l)
                if next_hop is None:
                    continue
                solver.add(
                    var[s][l]["phi"] + var[s][l]["trans"] + next_hop.t_proc + next_hop.t_sync
                    <= var[s][next_hop]["phi"]
                )

    # 时延约束
    @staticmethod
    def add_delay_const(solver: z3.Solver, var: VarDict) -> None:
        for s in var.keys():
            if s.s_type == "Prob": # 时延约束从0开始
                solver.add(s.ot + s.deadline >= var[s][s.last_link]["phi"]+ var[s][s.last_link]["trans"] + s.last_link.t_sync)
            else:

                solver.add(
                    var[s][s.first_link]["phi"] + s.deadline
                    >= var[s][s.last_link]["phi"] + var[s][s.last_link]["trans"] + s.last_link.t_sync
                )

    # 帧重叠
    #1. 两个帧属于不同的概率流不能重叠
    #2. 两个帧属于一个概率流与一个tt流不重叠
    #3. 两个tt流不重叠
    @staticmethod
    def add_link_const(
        solver: z3.Solver, var: VarDict, net: utils.Network, task: utils.StreamSet
    ) -> None:
        for l in net.links:
            for s1, s2 in task.get_pairs_on_link(l):
                if s1.s_type != "Prob" or s2.s_type != "Prob" or (s1.s_type == "Prob" and s2.s_type == "Prob" and s1.shareOrET !=s2.shareOrET):
                    for f1, f2 in task.get_frame_index_pairs(s1, s2):
                        solver.add(
                            z3.Or(
                                var[s1][l]["phi"] + f1 * s1.period
                                >= var[s2][l]["phi"] + f2 * s2.period + var[s2][l]["trans"],
                                var[s2][l]["phi"] + f2 * s2.period
                                >= var[s1][l]["phi"] + f1 * s1.period + var[s1][l]["trans"],
                            )
                        )

    # 增加队列的约束 ET流在0号队列、其它都是TT流的队列
    @staticmethod
    def add_queue_range_const(solver: z3.Solver, var: VarDict) -> None:
        for s in var.keys():
            for l in var[s].keys():
                if s.s_type == "Prob":
                    solver.add(var[s][l]["p"] == 0)
                else:
                    solver.add(1 <= var[s][l]["p"])
                    solver.add(var[s][l]["p"] < l.q_num)

    # 帧隔离约束：针对于来自相同的ET流的帧不需要帧隔离
    @staticmethod
    def add_frame_isolation_const(
        solver: z3.Solver, var: VarDict, task: utils.StreamSet
    ) -> None:
        for s1, s2 in task.get_pairs(): #返回一个二元组，0，1  0，2 1，2
            if s1.s_type != "Prob" or s2.s_type != "Prob" or (s1.s_type == "Prob" and s2.s_type == "Prob" and s1.shareOrET !=s2.shareOrET):
                for pl_1, pl_2, l in task.get_merged_links(s1, s2):  # 分别是第一条流的共享链路的前一个节点，第二条流的共享链路的前一个节点
                    for f1, f2 in task.get_frame_index_pairs(s1, s2):    # 一个周期传输几个帧         
                        solver.add(
                            z3.Or(
                                var[s2][l]["phi"] + f2 * s2.period + l.t_sync # 在本周期内s1的时隙在前面，s2的时隙在后面
                                <= var[s1][pl_1]["phi"] + f1 * s1.period + pl_1.t_proc,
                                var[s1][l]["phi"] + f1 * s1.period + l.t_sync # 控制s2在上一个链路上的发送时间+交换机的处理时延小于s1在本周期的发送时间
                                <= var[s2][pl_2]["phi"] + f2 * s2.period + pl_2.t_proc,
                                var[s1][l]["p"] != var[s2][l]["p"], #不在同一个队列
                            )
                        )

    
    @staticmethod
    def get_gcl_list(result, var: VarDict, lcm: int) -> utils.GCL:
        gcl = []
        for s in var.keys():
            for l in var[s].keys():
                queue = result[var[s][l]["p"]].as_long()
                release = result[var[s][l]["phi"]].as_long()
                for k in s.get_frame_indexes(lcm):
                    gcl.append(
                        [
                            l,
                            queue,
                            release + k * s.period,
                            release + k * s.period + var[s][l]["trans"],
                            lcm,
                            s._id,
                            s.shareOrET,
                        ]
                    )
        return utils.GCL(gcl)

    @staticmethod
    def get_release_time(result, var: VarDict) -> utils.Release:
        release = []
        for s in var.keys():
            release.append([s, 0, result[var[s][s.first_link]["phi"]].as_long()])
        return utils.Release(release)

    @staticmethod
    def get_queue_assignment(result, var) -> utils.Queue:
        queue = []
        for s in var.keys():
            for l in var[s].keys():
                queue.append([s, 0, l, result[var[s][l]["p"]].as_long()])
        return utils.Queue(queue)

    @staticmethod
    def get_route(var) -> utils.Route:
        route = []
        for s in var.keys():
            for l in var[s].keys():
                route.append([s, l])
        return utils.Route(route)

    @staticmethod
    def get_delay(result, var) -> utils.Delay:
        delay = []
        for s in var.keys():
            _delay = (
                result[var[s][s.last_link]["phi"]].as_long()
                - result[var[s][s.first_link]["phi"]].as_long()
            )
            delay.append([s, 0, _delay])
        return utils.Delay(delay)


if __name__ == "__main__":
    args = utils.parse_command_line_args()
    utils.Statistics().header()
    benchmark(args.name, args.task, args.net, args.output, args.workers)
